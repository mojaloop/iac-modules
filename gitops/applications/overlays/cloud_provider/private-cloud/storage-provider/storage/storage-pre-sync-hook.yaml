apiVersion: batch/v1
kind: Job
metadata:
  name: check-sc-ceph-resources
  namespace: ${ARGOCD_ENV_storage_namespace}
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded
    argocd.argoproj.io/sync-wave: '-90'
spec:
  template:
    spec:
      volumes:
      - name: kubeconfig-vol
        secret:
          secretName: "${ARGOCD_ENV_capi_cluster_name}-kubeconfig"
      containers:
      - name: check-sc-ceph-resources
        image: bitnami/kubectl:latest
        volumeMounts:
        - name: kubeconfig-vol
          mountPath: /kubeconfig
          readOnly: true
        env:
         - name: KUBECONFIG
           value: /kubeconfig/value
        command:
        - /bin/sh
        - -c
        - |
          set -e
          INTERVAL=10
          TIMEOUT=600
          NAMESPACE="rook-ceph"

          check_external_config_secret() {
          local SECRET_NAME="rook-external-config"

          echo "üîç Checking if secret '$SECRET_NAME' in namespace '$NAMESPACE' exists and is not empty..."
          SECONDS=0
          until kubectl get secret -n "$NAMESPACE" "$SECRET_NAME" -o jsonpath='{.data}' 2>/dev/null | grep -q '[^[:space:]]'; do
            if [ $SECONDS -ge $TIMEOUT ]; then
              echo "‚ùå Timeout waiting for secret '$SECRET_NAME' to exist and contain data."
              exit 1
            fi
            echo "‚è≥ Secret '$SECRET_NAME' not ready yet..."
            sleep $INTERVAL
          done
          echo "‚úÖ Secret '$SECRET_NAME' exists and contains data."
          }

          check_cm_external_cluster_user_command() {
            local CM_NAME="external-cluster-user-command"
            echo "üîç Checking if ConfigMap '$CM_NAME' in namespace '$NAMESPACE' exists and is not empty..."
            SECONDS=0
            until kubectl get configmap -n "$NAMESPACE" "$CM_NAME" -o jsonpath='{.data}' 2>/dev/null | grep -q '[^[:space:]]'; do
              if [ $SECONDS -ge $TIMEOUT ]; then
                echo "‚ùå Timeout waiting for ConfigMap '$CM_NAME' to exist and contain data."
                exit 1
              fi
              echo "‚è≥ ConfigMap '$CM_NAME' not ready yet..."
              sleep $INTERVAL
            done
            echo "‚úÖ ConfigMap '$CM_NAME' exists and contains data."
          }

          check_cm_rook_ceph_mon_endpoints_external() {
            local CM_NAME="rook-ceph-mon-endpoints-external"
            echo "üîç Checking if ConfigMap '$CM_NAME' in namespace '$NAMESPACE' exists and is not empty..."
            SECONDS=0
            until kubectl get configmap -n "$NAMESPACE" "$CM_NAME" -o jsonpath='{.data}' 2>/dev/null | grep -q '[^[:space:]]'; do
              if [ $SECONDS -ge $TIMEOUT ]; then
                echo "‚ùå Timeout waiting for ConfigMap '$CM_NAME' to exist and contain data."
                exit 1
              fi
              echo "‚è≥ ConfigMap '$CM_NAME' not ready yet..."
              sleep $INTERVAL
            done
            echo "‚úÖ ConfigMap '$CM_NAME' exists and contains data."
          }

          # Run checks in background
          check_external_config_secret &
          PID1=$!
          check_cm_external_cluster_user_command &
          PID2=$!
          check_cm_rook_ceph_mon_endpoints_external &
          PID3=$!

          # Wait for all to finish
          wait $PID1
          wait $PID2
          wait $PID3

          echo "‚úÖ All Configmaps and secrets are ready"
      restartPolicy: OnFailure
      serviceAccountName: storage-job-sa
  backoffLimit: 5
  ttlSecondsAfterFinished: 100