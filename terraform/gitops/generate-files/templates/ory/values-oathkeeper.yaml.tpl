global:
  ory:
    oathkeeper:
      maester:
        mode: controller
# -- Number of ORY Oathkeeper members
replicaCount: 1

# -- Full chart name override
fullnameOverride: "oathkeeper"

# -- Configure ORY Oathkeeper itself
oathkeeper:
  # -- The ORY Oathkeeper configuration. For a full list of available settings, check:
  #   https://github.com/ory/oathkeeper/blob/master/docs/config.yaml
  config:
    log:
      level: info
      format: json
    access_rules:
      matching_strategy: regexp
    
    authenticators:
      jwt:
        enabled: true
        config:
          jwks_urls:
            - https://${keycloak_fqdn}/realms/${keycloak_kratos_realm_name}/protocol/openid-connect/certs  
      cookie_session:
        enabled: true
        config:
          # this should be the internal URL of the public Kratos service's whoami endpoint, which might look like the below
          check_session_url: http://kratos-public/sessions/whoami
          preserve_path: true
          # this means we automatically sweep up all the metadata kratos provides for use
          # in, for example, the JWT, if we ever have more
          extra_from: "@this"
          # kratos will be configured to put the subject from the IdP here
          subject_from: "identity.traits.subject"
          only:
          - ory_kratos_session
      #will add keycloak jwt reference here
      anonymous:
        enabled: true
        config:
          subject: guest
    
    authorizers:
      allow:
        enabled: true
      remote_json:
        enabled: true
        config:
          # the check URL for Keto. This will be POST'd to. See https://www.ory.sh/keto/docs/reference/rest-api#operation/postCheck
          remote: http://keto-read/check
          payload: ""
    
    mutators:
      id_token:
        enabled: true
        config:
          issuer_url: http://oathkeeper-api:4456/
          jwks_url: http://oathkeeper:4456/.well-known/jwks.json
      header:
        # Set enabled to true if the authenticator should be enabled and false to disable the authenticator. Defaults to false.
        enabled: true
        config:
          headers:
            X-User: '{{ print .Subject }}'
            X-Extra: '{{ print .Extra }}'
            # X-Email: '{{ print .Extra.identity.traits.email }}'

    
    errors:
      fallback:
        - json
      handlers:
        json:
          # this gives API clients pretty error JSON
          enabled: true
          config:
            verbose: true
        redirect:
          enabled: false
        #   config:
        #     # set this to whatever the main URL is, it'll ensure that browser errors redirect there
        #     to: https://auth.awsdev.labsk8s1009.mojaloop.live/
        #     when:
        #     - error:
        #       - unauthorized
        #       - forbidden
        #       request: 
        #         header:
        #           accept:
        #           - text/html
    serve:
      proxy:
        port: 4455
      api:
        port: 4456
  # -- If set, uses the given JSON Web Key Set as the signing key for the ID Token Mutator.
  mutatorIdTokenJWKs: {}
  # -- If set, uses the given access rules.
  # accessRules: {}

  # -- If you enable maester, the following value should be set to "false" to avoid overwriting
  # the rules generated by the CDRs. Additionally, the value "accessRules" shouldn't be
  # used as it will have no effect once "managedAccessRules" is disabled.
  managedAccessRules: false



# -- Configure node affinity
affinity: {}

## -- Configures controller setup
maester:
  enabled: true
  oathkeeperFullnameOverride: 'oathkeeper'

oathkeeper-maester:
  fullnameOverride: 'oathkeeper-maester'
  oathkeeperFullnameOverride: 'oathkeeper'
  deployment:
    envs:
    - name: authorizersAvailable
      value: allow,deny,noop,remote_json

## -- Parameters for the Prometheus ServiceMonitor objects.
# Reference: https://docs.openshift.com/container-platform/4.6/rest_api/monitoring_apis/servicemonitor-monitoring-coreos-com-v1.html
serviceMonitor:
  # -- HTTP scheme to use for scraping.
  scheme: http
  # -- Interval at which metrics should be scraped
  scrapeInterval: 60s
  # -- Timeout after which the scrape is ended
  scrapeTimeout: 30s
  # -- Provide additional metricRelabelings to apply to samples before ingestion.
  metricRelabelings: []
  # -- Provide additional relabelings to apply to samples before scraping
  relabelings: []
  # -- Provide additional labels to the ServiceMonitor resource metadata
  labels: {}
  # -- TLS configuration to use when scraping the endpoint
  tlsConfig: {}
  # -- Additional metric labels
  targetLabels: []
